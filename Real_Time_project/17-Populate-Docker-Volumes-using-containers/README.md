---
title: "Learn to Populate Data in Docker Volumes Using Docker Containers"
description: "Understand how to populate Docker volumes using Docker containers with read-write and read-only configurations using the '--mount' and '-v' flags."
---

# Learn to Populate Data in Docker Volumes Using Docker Containers

---

## Introduction

In this guide, you will learn how to:

1. Create a Docker image with Nginx serving static content for various Docker Volume demos.
2. Populate a Docker volume using containers with both read-write and read-only permissions.
   - **Option 1:** Using the `--mount` flag.
   - **Option 2:** Using the `-v` flag.
3. Manage Docker volumes effectively, ensuring data persistence and security.

Docker volumes are essential for persisting data generated by and used by Docker containers. They allow data to survive container restarts and can be shared among multiple containers.

---

## Step 1: Create a Docker Image with Nginx Static Content

### Step 1.1: Review Dockerfile

**Dockerfile**

```dockerfile
# Use nginx:alpine-slim as base Docker Image
FROM nginx:alpine-slim

# OCI Labels
LABEL org.opencontainers.image.authors="Kalyan Reddy Daida"
LABEL org.opencontainers.image.title="Demo: Populate Docker Volumes with Containers"
LABEL org.opencontainers.image.description="A Dockerfile demo illustrating how to populate Docker volumes using containers and serving static content with NGINX."
LABEL org.opencontainers.image.version="1.0"

# Using COPY to copy local static content to Nginx HTML directory
COPY ./static-content/ /usr/share/nginx/html
```

**Explanation:**

- **FROM nginx:alpine-slim:** Uses the lightweight Alpine-based Nginx image.
- **LABELs:** Provide metadata about the image.
- **COPY ./static-content/ /usr/share/nginx/html:** Copies all files from the `static-content` directory on the host to Nginx's default HTML directory inside the container.

### Step 1.2: Review Static Content

**Directory Structure:**

```
Dockerfiles/
├── Dockerfile
└── static-content/
    ├── app1/
    │   └── index.html
    ├── file1.html
    ├── file2.html
    ├── file3.html
    ├── file4.html
    ├── file5.html
    └── index.html
```


### Step 1.3: Build a Docker Image
```bash
# Change Directory
cd Dockerfiles

# Build Docker Image
docker build -t <IMAGE_NAME>:<TAG> .
docker build -t mynginx-static:v1 .

# List Docker Images
docker images

# Run Docker Container and Verify
docker run --name=volumes-demo-base-container -p 8090:80 -d mynginx-static:v1

# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Access Application
http://localhost:8090
Observation:
1. We have all our static content present and accessible
```

---

## Step 2: Populate a Volume Using Container

Populating a Docker volume involves mounting it to a container's directory. When a volume is mounted to a directory that already contains data, Docker copies the existing data into the volume. This ensures that the volume starts with the container's initial data.

### Option 1: Using `--mount` Flag

The `--mount` flag provides a more verbose and explicit syntax for mounting volumes.

#### Step 2.1: Using `--mount` Flag with Read-Write Access

**Command:**

```bash
# Single Line Format
docker run --name volume-demo1 -p 8091:80 --mount type=volume,source=myvol103,target=/usr/share/nginx/html -d mynginx-static:v1

# Readable Multi-Line Format
docker run \
    --name volume-demo1 \
    -p 8091:80 \
    --mount type=volume,source=myvol103,target=/usr/share/nginx/html \
    -d \
    mynginx-static:v1
```

**Explanation:**

- `--name volume-demo1`: Names the container `volume-demo1`.
- `-p 8091:80`: Maps host port `8091` to container port `80`.
- `--mount type=volume,source=myvol103,target=/usr/share/nginx/html`: Mounts the named volume `myvol103` to `/usr/share/nginx/html` inside the container.
- `-d mynginx-static:v1`: Runs the container in detached mode using the `mynginx-static:v1` image.

#### Step 2.2: Verify the Volume Mount

```bash
# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Connect to the Container
docker exec -it volume-demo1 /bin/sh

# Inside the Container: Check Disk Usage
df -h

# Navigate to the Mounted Directory
cd /usr/share/nginx/html
ls

# Exit the Container Shell
exit
```

**Observations:**

1. A new Docker volume `myvol103` is created and mounted to `/usr/share/nginx/html`.
2. The static content from the Docker image is successfully copied to the volume.
3. There is no data loss; the volume contains the initial data from the image.
4. This demonstrates the advantage of using volumes for data persistence.

#### Step 2.3: Inspect the Docker Container

```bash
# Inspect Container Details
docker inspect volume-demo1

# Extract Mounts Information in JSON Format
docker inspect --format='{{json .Mounts}}' volume-demo1

# Pretty-Print Mounts Information Using jq
docker inspect --format='{{json .Mounts}}' volume-demo1 | jq
```

**Explanation:**

- These commands provide detailed information about the container's mounts, showing that `myvol103` is correctly mounted to `/usr/share/nginx/html`.

#### Step 2.4: Access the Application

```bash
# Access via Browser
http://localhost:8091

# Access via curl
curl http://localhost:8091
```

**Observation:**

- All static content is accessible, confirming that the volume has been populated correctly.

### Option 2: Using `-v` Flag

The `-v` or `--volume` flag offers a shorthand syntax for mounting volumes.

#### Step 2.5: Using `-v` Flag with Read-Write Access

**Command:**

```bash
# Single Line Format
docker run --name volume-demo3 -p 8093:80 -v myvol103:/usr/share/nginx/html -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo3 \
    -p 8093:80 \
    -v myvol103:/usr/share/nginx/html \
    -d \
    nginx:alpine-slim
```

**Explanation:**

- `-v myvol103:/usr/share/nginx/html`: Mounts the named volume `myvol103` to `/usr/share/nginx/html` inside the container with read-write permissions.

#### Step 2.6: Verify the Volume Mount

```bash
# List Docker Containers
docker ps
docker ps --format "table {{.Image}}\t{{.Names}}\t{{.Status}}\t{{.ID}}\t{{.Ports}}"

# Connect to the Container
docker exec -it volume-demo3 /bin/sh

# Inside the Container: Check Disk Usage
df -h

# Navigate to the Mounted Directory
cd /usr/share/nginx/html
ls

# Exit the Container Shell
exit
```

**Observations:**

1. The volume `myvol103` is mounted to `/usr/share/nginx/html`.
2. The static content is present and accessible within the container.

#### Step 2.7: Modify Content (Read-Write)

```bash
# Connect to the Container
docker exec -it volume-demo3 /bin/sh

# Inside the Container: Copy a File
cd /usr/share/nginx/html
cp index.html kalyan.html

# Exit the Container Shell
exit

# Access the New File via Browser
http://localhost:8093/kalyan.html

# Access the New File via curl
curl http://localhost:8093/kalyan.html
```

**Observation:**

- The file `kalyan.html` is successfully created and accessible, indicating that the volume is mounted with read-write permissions.

### Option 3: Mounting a Volume as Read-Only

#### Step 2.8: Using `--mount` Flag with Read-Only Access

```bash
# Single Line Format
docker run --name volume-demo4 -p 8094:80 --mount source=myvol103,target=/usr/share/nginx/html,readonly -d nginx:alpine-slim

# Readable Multi-Line Format
docker run \
    --name volume-demo4 \
    -p 8094:80 \
    --mount source=myvol103,target=/usr/share/nginx/html,readonly \
    -d \
    nginx:alpine-slim
```

**Explanation:**

- `readonly`: Mounts the volume as read-only, preventing any write operations within the container.

#### Step 2.9: Verify Read-Only Mount

```bash
# Connect to the Container
docker exec -it volume-demo4 /bin/sh

# Inside the Container: Attempt to Copy a File
cd /usr/share/nginx/html
cp index.html reddy.html

# Expected Output:
# cp: can't create 'reddy.html': Read-only file system

# Exit the Container Shell
exit

# Access the Application in Browser
http://localhost:8094
```

**Observations:**

1. Attempting to create or modify files within `/usr/share/nginx/html` fails due to read-only permissions.
2. The static content remains accessible but immutable.

#### Step 2.10: Using `-v` Flag with Read-Only Access

```bash
# Single Line Format
docker run --name volume-demo5 -p 8095:80 -v myvol103:/usr/share/nginx/html:ro -d nginx:alpine-slim

# Readable Multi-Line Format
  docker run \
      --name volume-demo5 \
      -p 8095:80 \
      -v myvol103:/usr/share/nginx/html:ro \
      -d \
      nginx:alpine-slim
```

**Explanation:**

- `-v myvol103:/usr/share/nginx/html:ro`: Mounts the named volume `myvol103` to `/usr/share/nginx/html` inside the container with read-only permissions.

#### Step 2.11: Verify Read-Only Mount

```bash
# Connect to the Container
docker exec -it volume-demo5 /bin/sh

# Inside the Container: Attempt to Copy a File
cd /usr/share/nginx/html
cp index.html reddy.html

# Expected Output:
# cp: can't create 'reddy.html': Read-only file system

# Exit the Container Shell
exit

# Access the Application in Browser
http://localhost:8095/kalyan.html
```

**Observation:**

- Similar to `volume-demo4`, attempting to modify files results in an error, ensuring the volume is mounted as read-only.

---

## Step 3: Clean-Up - NO CLEANUP - VOLUME (myvol103) will be re-used in next demo

After completing the demos, it's important to clean up Docker resources to free up system resources and maintain a tidy environment.

```bash
# Delete All Containers
docker rm -f $(docker ps -aq)

# Delete All Docker Images
docker rmi $(docker images -q)

# Optionally, remove specific volumes
docker volume rm myvol101 myvol102 myvol103
```

**Notes:**

- **Caution:** The above commands will remove all containers and images from your system. Ensure that you do not need any of them before executing these commands.
- To remove specific volumes, list them using `docker volume ls` and then remove as needed.

---

## Conclusion

You have successfully:

- Created a Docker image with Nginx serving static content.
- Populated Docker volumes using containers with both read-write and read-only permissions.
  - Used the `--mount` flag for explicit volume mounting.
  - Used the `-v` flag for shorthand volume mounting.
- Verified the integrity and permissions of mounted volumes.
- Cleaned up Docker containers, images, and volumes.

Docker volumes are a powerful feature for managing persistent data in containers, allowing data to persist across container lifecycles and facilitating data sharing among multiple containers.

---

## Additional Notes

- **`--mount` vs. `-v` Flags:**
  
  - **`--mount` Flag:**
    - More verbose and explicit.
    - Recommended for complex configurations.
    - Syntax: `--mount type=volume,source=<VOLUME_NAME>,target=<CONTAINER_PATH>,readonly`
  
  - **`-v` Flag:**
    - Shorthand syntax.
    - Suitable for simple volume mounts.
    - Syntax: `-v <VOLUME_NAME>:<CONTAINER_PATH>:ro`

- **Volume Persistence:**
  
  - Data stored in Docker volumes persists even after the container is removed.
  - Volumes are stored outside the container's writable layer, ensuring data integrity and isolation.

- **Best Practices:**
  
  - Use named volumes for better management and clarity.
  - Use read-only mounts for data that should not be modified by the container.
  - Regularly clean up unused volumes to free up disk space.

- **Security Considerations:**
  
  - Mounting volumes with appropriate permissions enhances container security.
  - Avoid mounting sensitive directories or files unless necessary.

---

## Additional Resources

- [Docker Documentation - Use Volumes](https://docs.docker.com/storage/volumes/)
- [Docker CLI Reference](https://docs.docker.com/engine/reference/commandline/docker/)
- [Differences Between `-v` and `--mount`](https://docs.docker.com/storage/#choose-the--v-or---mount-flag)
- [Docker Storage Drivers](https://docs.docker.com/storage/storagedriver/select-storage-driver/)
- [Docker Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)

---
    
**Happy Dockerizing!**
